package com.brightcove.rentallicensesample;

import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.util.Log;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class BrightcoveMediaDrmCallback {
    /**
     * The identifier that will be used to tag all log generated by this class.
     */
    private static final String TAG = BrightcoveMediaDrmCallback.class.getSimpleName();
    /**
     * The name of the property in the video properties map that specified the default URL to the
     * DRM license service that should be used if the request does not include an URL.
     */
    public static final String DEFAULT_URL = "defaultUrl";
    /**
     * A map of HTTP headers that should be added to the license request.
     */
    protected static final Map<String, String> REQUEST_HEADERS =
            Collections.singletonMap("Content-Type", "application/octet-stream");
    /**
     * The base URL to Brightcove DRM license service.
     */
    protected static final String BRIGHTCOVE_BASE_URL = "https://wvlic.brightcove.com/proxy/";
    /**
     * The fully qualified URL to the DRM license service that will be used if the request does
     * include an URL.
     */
    protected final String defaultUrl;
    /**
     * Lock of synchronizing the read/write operations one {@link #optionalHeaders}.
     */
    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    /**
     * Optional request headers to be passed to the license key request.
     */
    private Map<String, String> optionalHeaders;

    protected BrightcoveMediaDrmCallback(@Nullable String defaultUrl) {
        this.defaultUrl = defaultUrl;
    }

    /**
     * Gets the optional request headers that will be passed to the license key request.
     *
     * @return null or reference to an immutable map of request headers.
     */
    @Nullable
    public Map<String, String> getOptionalHeaders() {
        lock.readLock().lock();
        try {
            return optionalHeaders;
        } finally {
            lock.readLock().unlock();
        }
    }

    public void setOptionalHeaders(@Nullable Map<String, String> optionalHeaders) {
        lock.writeLock().lock();
        try {
            this.optionalHeaders = optionalHeaders;
        } finally {
            lock.writeLock().unlock();
        }
    }

    protected void setVideoHeaders(@NonNull Map<String, Object> videoProperties) {
        Map<String, String> headerValues = new HashMap<>();

        try {
            Object value = videoProperties.get("widevineHeaders");
            if (value != null && value instanceof Map) {
                @SuppressWarnings("unchecked")
                Map<String, String> headers = (Map<String, String>) value;
                Log.i("DRM", "Adding headers for Widevine call: " + headers);
                for (Map.Entry<String, String> entry : headers.entrySet()) {
                    headerValues.put(entry.getKey(), entry.getValue());
                }
            }
        } catch (Exception exception) {
            Log.w(TAG, "Failed to use Video headers.", exception);
        }
        setOptionalHeaders(headerValues);
    }
}
